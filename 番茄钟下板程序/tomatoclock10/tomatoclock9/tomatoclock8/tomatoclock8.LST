C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE TOMATOCLOCK8
OBJECT MODULE PLACED IN tomatoclock8.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE tomatoclock8.c BROWSE INCDIR(.\inc) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "STC15F2K60S2.H"
   2          #include "sys.H"
   3          #include "displayer.H"
   4          #include "key.h"
   5          #include "IR.h"
   6          #include "beep.h"
   7          #include "adc.h"
   8          #include "music.h"
   9          #include "M24C02.h"
  10          #include "DS1302.h"
  11          #include "oled.h"
  12          #include "uart1.h"
  13          #include "guanshanjiu.h"
*** WARNING C245 IN LINE 1 OF guanshanjiu.h: unknown #pragma, line ignored
  14          #include <string.h>
  15          
  16          
  17          code unsigned long SysClock = 11059200;
  18          
  19          struct_DS1302_RTC xdata time;
  20          
  21          
  22          code char decode_table[] = {
  23              0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f,
  24              0x40, 0x00  
  25          };
  26          
  27          // ????
  28          enum {
  29              MODE_NORMAL = 0,
  30              MODE_SET_TIME,
  31              MODE_COUNTDOWN,
  32              MODE_LED_CONTROL
  33          };
  34          
  35          // ??????
  36          enum {
  37              CURSOR_HOUR = 0,
  38              CURSOR_MINUTE,
  39              CURSOR_SECOND
  40          };
  41          
  42          // ?????? (??)
  43          enum {
  44              CMD_STOP = 1,
  45              CMD_START_TIMER,
  46              CMD_LED_CONTROL
  47          };
  48          
  49          // ?????PC????????
  50          enum {
  51              CMD_SET_POMODORO_PC = 0,
  52              CMD_UNLOCK_PC = 1,
  53              CMD_LOCK_PC = 2,
  54              CMD_UPDATE_TIME_PC = 4
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 2   

  55          };
  56          
  57          // ????
  58          unsigned char xdata time_set[3] = {0, 25, 0};
  59          unsigned char xdata current_time[3] = {0, 0, 0};
  60          unsigned char xdata cursor_pos = CURSOR_SECOND;
  61          unsigned char xdata function_mode = MODE_NORMAL;
  62          unsigned char xdata blink_counter = 0;
  63          unsigned char xdata inactivity_timer = 0;
  64          unsigned char xdata countdown_active = 0;
  65          unsigned char xdata led_selection = 0;
  66          unsigned char xdata ir_tx_buf[5] = {CMD_START_TIMER, 0, 0, 0, 0};
  67          unsigned char xdata uart1_rx_buf[5]; // ????
  68          bit blink_state = 0;
  69          bit countdown_paused = 0;
  70          bit led_control_active = 0;
  71          unsigned char xdata data_buf[5];
  72          
  73          unsigned char xdata current_song_index = 0;
  74          bit music_playing = 0;
  75          bit music_paused = 0;
  76          // ???????
  77          
  78          // ??????
  79          void update_display();
  80          void handle_key1();
  81          void handle_key2();
  82          void handle_nav(unsigned char nav_key);
  83          void enter_setting_mode();
  84          void exit_setting_mode();
  85          void start_countdown();
  86          void stop_countdown();
  87          void update_countdown();
  88          void save_settings();
  89          void load_settings();
  90          void beep_confirm();
  91          void beep_error();
  92          void beep_countdown_end();
  93          void send_tomato_command();
  94          void enter_led_control_mode();
  95          void exit_led_control_mode();
  96          void update_led_display();
  97          void send_led_command();
  98          void send_data_to_pc(unsigned char cmd, unsigned char d1, unsigned char d2, unsigned char d3, unsigned cha
             -r d4); // ????
  99          void delay_ms(unsigned int ms); // ????
 100          void uart_rx_callback(void);   // ????
 101          
 102          
 103          // ????????
 104          /*void delay_ms(unsigned int ms)
 105          {
 106              unsigned int i, j;
 107              for (i = ms; i > 0; i--)
 108                  for (j = 800; j > 0; j--);
 109          }*/
 110          extern void delay_ms(unsigned int ms);
 111          
 112          // ?????????? (????1)
 113          void send_data_to_pc(unsigned char cmd, unsigned char d1, unsigned char d2, unsigned char d3, unsigned cha
             -r d4)
 114          {
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 3   

 115   1      
 116   1          data_buf[0] = cmd;
 117   1          data_buf[1] = d1;
 118   1          data_buf[2] = d2;
 119   1          data_buf[3] = d3;
 120   1          data_buf[4] = d4;
 121   1          Uart1Print(data_buf, 5);
 122   1      }
 123          
 124          void Rop_callback(){
 125   1        if(GetADC().Rop<10)
 126   1          SetBeep(1200,150);
 127   1        else if(GetADC().Rop>100){
 128   2          SetBeep(2000,150);
 129   2        }
 130   1      }
 131          
 132          // ????????????
 133          void uart_rx_callback()
 134          {
 135   1          // ???????,???1???,??????“???”
 136   1          
 137   1          unsigned char received_cmd = uart1_rx_buf[0];
 138   1      
 139   1          // ????????? PC ?????“??/??”?? (CMD_UNLOCK_PC ??? 1)
 140   1          if (received_cmd == CMD_UNLOCK_PC)
 141   1          { 
 142   2              
 143   2            // ?????,????????????????
 144   2              SetBeep(800, 50);
 145   2              delay_ms(100); // ????????
 146   2              SetBeep(800, 50);
 147   2              if (function_mode == MODE_COUNTDOWN)
 148   2              {
 149   3                  // ???,?????????? stop_countdown() ??
 150   3                  
 151   3                  stop_countdown();
 152   3                  
 153   3              }
 154   2          }
 155   1          else if (received_cmd == CMD_LED_CONTROL){
 156   2              SetBeep(800, 50);
 157   2              delay_ms(100); // ????????
 158   2              SetBeep(800, 50);
 159   2              if (uart1_rx_buf[1]>=10){
 160   3                OLED_Clear();
 161   3                OLED_ShowCHinese(10, 2, 52);
 162   3                OLED_ShowCHinese(25, 2, 53);
 163   3                OLED_ShowCHinese(40, 2, 59);
 164   3                OLED_ShowCHinese(55, 2, 60);
 165   3                OLED_ShowCHinese(70, 2, 61);
 166   3                OLED_ShowCHinese(10, 4, 68);
 167   3                OLED_ShowCHinese(25, 4, 69);
 168   3                OLED_ShowCHinese(40, 4, 62);
 169   3                OLED_ShowCHinese(55, 4, 63);
 170   3                OLED_ShowCHinese(70, 4, 31);
 171   3                OLED_ShowCHinese(85, 4, uart1_rx_buf[1]+54);
 172   3                Seg7Print(uart1_rx_buf[2]/10, uart1_rx_buf[2]%10, 10, uart1_rx_buf[3]/10,
 173   3                          uart1_rx_buf[3]%10, 10, uart1_rx_buf[4]/10, uart1_rx_buf[4]%10);
 174   3              }
 175   2              else if (uart1_rx_buf[1]==2){
 176   3                OLED_Clear();
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 4   

 177   3                OLED_ShowCHinese(10, 2, 95);
 178   3                OLED_ShowCHinese(25, 2, 62);
 179   3                OLED_ShowCHinese(40, 2, 96);
 180   3                OLED_ShowCHinese(55, 2, 97);
 181   3                OLED_ShowCHinese(70, 2, 98);
 182   3                OLED_ShowCHinese(85, 2, 99);
 183   3                OLED_ShowCHinese(10, 4, 76);
 184   3                OLED_ShowCHinese(25, 4, 77);
 185   3                OLED_ShowCHinese(40, 4, 78);
 186   3                OLED_ShowCHinese(55, 4, uart1_rx_buf[2] + 78);
 187   3                OLED_ShowCHinese(70, 4, 91);
 188   3                if(uart1_rx_buf[3]==1){OLED_ShowCHinese(85, 4, 92);OLED_ShowCHinese(100, 4, 94);}
 189   3                else if(uart1_rx_buf[3]==20){OLED_ShowCHinese(85, 4, 80);OLED_ShowCHinese(100, 4, 88);}
 190   3                else if(uart1_rx_buf[3]==30){OLED_ShowCHinese(85, 4, 81);OLED_ShowCHinese(100, 4, 88);}
 191   3                else if(uart1_rx_buf[3]==11){OLED_ShowCHinese(85, 4, 88);OLED_ShowCHinese(100, 4, 94);}
 192   3                else if(uart1_rx_buf[3]==21){OLED_ShowCHinese(85, 4, 93);OLED_ShowCHinese(100, 4, 94);}
 193   3                else if(uart1_rx_buf[3]>=2&&uart1_rx_buf[3]<=10){OLED_ShowCHinese(85, 4, 92);OLED_ShowCHinese(100, 4
             -,88+uart1_rx_buf[3]-10 );}//x+(x-10)
 194   3                else if(uart1_rx_buf[3]>=12&&uart1_rx_buf[3]<=19){OLED_ShowCHinese(85, 4, 88);OLED_ShowCHinese(100, 4
             -, uart1_rx_buf[3]%10+78);}
 195   3                else if(uart1_rx_buf[3]>=22&&uart1_rx_buf[3]<=29){OLED_ShowCHinese(85, 4, 93);OLED_ShowCHinese(100, 4
             -,uart1_rx_buf[3]%10+78 );}
 196   3                time = RTC_Read();
 197   3                Seg7Print(2, 0, 2, 5, time.month/10, time.month%10, time.day/10, time.day%10);
 198   3              }
 199   2          }
 200   1            
 201   1          
 202   1          // ????????PC?????,??????? else if
 203   1          // else if (received_cmd == ANOTHER_CMD_FROM_PC) { ... }
 204   1      }
 205          
 206          // Key1, Key2 ????
 207          void key_callback() {
 208   1          unsigned char xdata key_act;
 209   1          inactivity_timer = 0;
 210   1          
 211   1          key_act = GetKeyAct(enumKey1);
 212   1          if (key_act == enumKeyPress) {
 213   2              handle_key1();
 214   2          }
 215   1          
 216   1          key_act = GetKeyAct(enumKey2);
 217   1          if (key_act == enumKeyPress) {
 218   2              handle_key2();
 219   2          }
 220   1      }
 221          
 222          // ?????
 223          void nav_callback() {
 224   1          unsigned char xdata act;
 225   1          inactivity_timer = 0;
 226   1          
 227   1          act = GetAdcNavAct(enumAdcNavKeyUp);
 228   1          if (act == enumKeyPress) {
 229   2              if (function_mode == MODE_NORMAL) {
 230   3                  // ??:??/????
 231   3                  if (music_playing) {
 232   4                      if (music_paused) {
 233   5                          SetPlayerMode(enumModePlay); // ????
 234   5                          music_paused = 0;
 235   5                          beep_confirm();
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 5   

 236   5                          OLED_Clear();
 237   5                          OLED_ShowCHinese(10, 2, 70); // ?
 238   5                          OLED_ShowCHinese(25, 2, 71); // ?
 239   5                          OLED_ShowCHinese(40, 2, 43); // ?
 240   5                          OLED_ShowCHinese(10, 5, 73); // ?
 241   5                          OLED_ShowCHinese(25, 5, 74); // ?
 242   5                          OLED_ShowCHinese(40, 5, 75); // ?
 243   5                      }
 244   4                  } else {
 245   4                      // ????????
 246   4                      SetMusic(84,0xFE,guanshan,sizeof(guanshan),enumMscNull);
 247   4                      SetPlayerMode(enumModePlay);
 248   4                      music_playing = 1;
 249   4                      music_paused = 0;
 250   4                      beep_confirm();
 251   4                      OLED_Clear();
 252   4                      OLED_ShowCHinese(10, 2, 70); // ?
 253   4                      OLED_ShowCHinese(25, 2, 71); // ?
 254   4                      OLED_ShowCHinese(40, 2, 43); // ?
 255   4                      OLED_ShowCHinese(10, 5, 73); // ?
 256   4                      OLED_ShowCHinese(25, 5, 74); // ?
 257   4                      OLED_ShowCHinese(40, 5, 75); // ?
 258   4                  }
 259   3              } else {
 260   3                  handle_nav(enumAdcNavKeyUp);
 261   3              }
 262   2          }
 263   1          
 264   1          act = GetAdcNavAct(enumAdcNavKeyDown);
 265   1          if (act == enumKeyPress) {
 266   2              if (function_mode == MODE_NORMAL) {
 267   3                  // ??:????
 268   3                  if (music_playing && !music_paused) {
 269   4                      SetPlayerMode(enumModePause);
 270   4                      music_paused = 1;
 271   4                      beep_confirm();
 272   4                      OLED_Clear();
 273   4                      OLED_ShowCHinese(10, 2, 72); // ?
 274   4                      OLED_ShowCHinese(25, 2, 32); // ?
 275   4                      OLED_ShowCHinese(40, 2, 43); // ?
 276   4                  }
 277   3              } else {
 278   3                  handle_nav(enumAdcNavKeyDown);
 279   3              }
 280   2          }
 281   1          
 282   1          act = GetAdcNavAct(enumAdcNavKeyLeft);
 283   1          if (act == enumKeyPress) 
 284   1           {
 285   2                  handle_nav(enumAdcNavKeyLeft);
 286   2              }
 287   1          
 288   1          
 289   1          act = GetAdcNavAct(enumAdcNavKeyRight);
 290   1          if (act == enumKeyPress) {
 291   2             
 292   2                  handle_nav(enumAdcNavKeyRight);
 293   2              
 294   2          }
 295   1          
 296   1          act = GetAdcNavAct(enumAdcNavKeyCenter);
 297   1          if (act == enumKeyPress) handle_nav(enumAdcNavKeyCenter);
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 6   

 298   1      }
 299          
 300          void enter_led_control_mode() {
 301   1          function_mode = MODE_LED_CONTROL;
 302   1          led_control_active = 1;
 303   1          led_selection = 0;
 304   1          LedPrint(0x01);
 305   1          beep_confirm();
 306   1          update_led_display();
 307   1          
 308   1          OLED_Clear();
 309   1          OLED_ShowChar(10, 2, 'A', 16);
 310   1          OLED_ShowChar(25, 2, 'I', 16);
 311   1          OLED_ShowCHinese(40, 2, 47);
 312   1          OLED_ShowCHinese(55, 2, 48);
 313   1          OLED_ShowCHinese(70, 2, 49);
 314   1      }
 315          
 316          void exit_led_control_mode() {
 317   1          function_mode = MODE_NORMAL;
 318   1          led_control_active = 0;
 319   1          LedPrint(0x00);
 320   1          //beep_confirm();
 321   1          update_display();
 322   1      }
 323          
 324          void update_led_display() {
 325   1          char xdata disp_buf[8];
 326   1          char i;
 327   1          for (i = 0; i < 8; i++) {
 328   2              disp_buf[i] = (i == 7) ? led_selection : 10;
 329   2          }
 330   1          if (led_selection == 1){
 331   2          OLED_Clear();
 332   2          OLED_ShowCHinese(10, 2, 52);
 333   2          OLED_ShowCHinese(25, 2, 53);
 334   2          OLED_ShowCHinese(40, 2, 62);
 335   2          OLED_ShowCHinese(55, 2, 63);}
 336   1          else if (led_selection == 2){
 337   2          OLED_Clear();
 338   2          OLED_ShowCHinese(10, 2, 52);
 339   2          OLED_ShowCHinese(25, 2, 53);
 340   2          OLED_ShowCHinese(40, 2, 97);
 341   2          OLED_ShowCHinese(55, 2, 98);}
 342   1          
 343   1          Seg7Print(disp_buf[0], disp_buf[1], disp_buf[2], disp_buf[3],
 344   1                    disp_buf[4], disp_buf[5], disp_buf[6], disp_buf[7]);
 345   1      }
 346          
 347          void send_led_command() {
 348   1          ir_tx_buf[0] = CMD_LED_CONTROL;
 349   1          ir_tx_buf[1] = led_selection;
 350   1          ir_tx_buf[2] = 0;
 351   1          ir_tx_buf[3] = 0;
 352   1          ir_tx_buf[4] = 0;
 353   1          
 354   1          if (IrPrint(ir_tx_buf, 5) == enumIrTxOK) {
 355   2              beep_confirm();
 356   2              OLED_Clear();
 357   2              OLED_ShowCHinese(10, 2, 50);
 358   2              OLED_ShowCHinese(25, 2, 51);
 359   2              OLED_ShowCHinese(40, 2, 52);
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 7   

 360   2              OLED_ShowCHinese(55, 2, 53);
 361   2              OLED_ShowCHinese(70, 2, 54);
 362   2              OLED_ShowCHinese(10, 4, 55);
 363   2              OLED_ShowCHinese(25, 4, 56);
 364   2              OLED_ShowCHinese(40, 4, 57);
 365   2              OLED_ShowCHinese(55, 4, 58);
 366   2              delay_ms(100);
 367   2          } else {
 368   2              beep_error();
 369   2          }
 370   1          if (IrPrint(ir_tx_buf, 5) == enumIrTxOK) {
 371   2              beep_confirm();
 372   2              OLED_Clear();
 373   2              OLED_ShowCHinese(10, 2, 50);
 374   2              OLED_ShowCHinese(25, 2, 51);
 375   2              OLED_ShowCHinese(40, 2, 52);
 376   2              OLED_ShowCHinese(55, 2, 53);
 377   2              OLED_ShowCHinese(70, 2, 54);
 378   2              OLED_ShowCHinese(10, 4, 55);
 379   2              OLED_ShowCHinese(25, 4, 56);
 380   2              OLED_ShowCHinese(40, 4, 57);
 381   2              OLED_ShowCHinese(55, 4, 58);
 382   2              delay_ms(100);
 383   2          } else {
 384   2              beep_error();
 385   2          }
 386   1          Uart1Print(ir_tx_buf, 5);
 387   1      }
 388          
 389          void timer_1s_callback() {
 390   1          if (function_mode == MODE_COUNTDOWN && countdown_active && !countdown_paused) {
 391   2              update_countdown();
 392   2          }
 393   1          
 394   1          if (countdown_active && current_time[0] == 0 && current_time[1] == 0 && current_time[2] == 0) {
 395   2              stop_countdown();
 396   2              beep_countdown_end();
 397   2              OLED_Clear();
 398   2              OLED_ShowCHinese(10, 2, 18);
 399   2              OLED_ShowCHinese(25, 2, 19);
 400   2              OLED_ShowCHinese(40, 2, 34);
 401   2              OLED_ShowCHinese(10, 5, 11);
 402   2              OLED_ShowCHinese(25, 5, 12);
 403   2              OLED_ShowCHinese(40, 5, 13);
 404   2              OLED_ShowCHinese(55, 5, 32);
 405   2              OLED_ShowCHinese(70, 5, 33);
 406   2          }
 407   1             if (music_playing && GetPlayerMode() == enumModeStop) {
 408   2              music_playing = 0;
 409   2              music_paused = 0;
 410   2              OLED_Clear();
 411   2              OLED_ShowCHinese(10, 2, 64); // ?
 412   2              OLED_ShowCHinese(25, 2, 65); // ?
 413   2              OLED_ShowCHinese(40, 2, 70); // ?
 414   2              OLED_ShowCHinese(55, 2, 71); // ?
 415   2              OLED_ShowCHinese(70, 2, 72); // ?
 416   2              OLED_ShowCHinese(85, 2, 73); // ?
 417   2          }
 418   1      }
 419          
 420          
 421          void timer_100ms_callback() {
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 8   

 422   1          if (function_mode == MODE_SET_TIME) {
 423   2              blink_counter++;
 424   2              if (blink_counter >= 5) {
 425   3                  blink_counter = 0;
 426   3                  blink_state = !blink_state;
 427   3                  update_display();
 428   3              }
 429   2          }
 430   1          
 431   1          if (function_mode == MODE_SET_TIME) {
 432   2              inactivity_timer++;
 433   2              if (inactivity_timer >= 300) {
 434   3                  // exit_setting_mode();
 435   3              }
 436   2          }
 437   1      }
 438          
 439          void update_display() {
 440   1          char xdata disp_buf[8];
 441   1          
 442   1          if (function_mode == MODE_NORMAL) {
 443   2              disp_buf[0] = time_set[0] / 10;
 444   2              disp_buf[1] = time_set[0] % 10;
 445   2              disp_buf[2] = 10;
 446   2              disp_buf[3] = time_set[1] / 10;
 447   2              disp_buf[4] = time_set[1] % 10;
 448   2              disp_buf[5] = 10;
 449   2              disp_buf[6] = time_set[2] / 10;
 450   2              disp_buf[7] = time_set[2] % 10;
 451   2          } 
 452   1          else if (function_mode == MODE_SET_TIME) {
 453   2              disp_buf[0] = (blink_state || cursor_pos != CURSOR_HOUR) ? time_set[0] / 10 : 11;
 454   2              disp_buf[1] = (blink_state || cursor_pos != CURSOR_HOUR) ? time_set[0] % 10 : 11;
 455   2              disp_buf[2] = 10;
 456   2              disp_buf[3] = (blink_state || cursor_pos != CURSOR_MINUTE) ? time_set[1] / 10 : 11;
 457   2              disp_buf[4] = (blink_state || cursor_pos != CURSOR_MINUTE) ? time_set[1] % 10 : 11;
 458   2              disp_buf[5] = 10;
 459   2              disp_buf[6] = (blink_state || cursor_pos != CURSOR_SECOND) ? time_set[2] / 10 : 11;
 460   2              disp_buf[7] = (blink_state || cursor_pos != CURSOR_SECOND) ? time_set[2] % 10 : 11;
 461   2          }
 462   1          else if (function_mode == MODE_COUNTDOWN) {
 463   2              disp_buf[0] = current_time[0] / 10;
 464   2              disp_buf[1] = current_time[0] % 10;
 465   2              disp_buf[2] = 10;
 466   2              disp_buf[3] = current_time[1] / 10;
 467   2              disp_buf[4] = current_time[1] % 10;
 468   2              disp_buf[5] = 10;
 469   2              disp_buf[6] = current_time[2] / 10;
 470   2              disp_buf[7] = current_time[2] % 10;
 471   2          }
 472   1          else if (function_mode == MODE_LED_CONTROL) {
 473   2              update_led_display();
 474   2              return;
 475   2          }
 476   1          
 477   1          Seg7Print(disp_buf[0], disp_buf[1], disp_buf[2], disp_buf[3],
 478   1                    disp_buf[4], disp_buf[5], disp_buf[6], disp_buf[7]);
 479   1      }
 480          
 481          // ??Key1??(??/?????)
 482          void handle_key1() {
 483   1          // ????/???????(????/LED????)
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 9   

 484   1          if (function_mode == MODE_SET_TIME || function_mode == MODE_LED_CONTROL) return;
 485   1          
 486   1          if (function_mode == MODE_NORMAL) {
 487   2              // ????:?????
 488   2              start_countdown();
 489   2              OLED_Clear();
 490   2              OLED_ShowCHinese(10, 2, 11);
 491   2              OLED_ShowCHinese(25, 2, 12);
 492   2              OLED_ShowCHinese(40, 2, 13);
 493   2              OLED_ShowCHinese(55, 2, 14);
 494   2              OLED_ShowCHinese(70, 2, 15);
 495   2              OLED_Clear();
 496   2              OLED_ShowCHinese(10, 2, 11);
 497   2              OLED_ShowCHinese(25, 2, 12);
 498   2              OLED_ShowCHinese(40, 2, 13);
 499   2              OLED_ShowCHinese(55, 2, 41);
 500   2              OLED_ShowCHinese(70, 2, 42);
 501   2              OLED_ShowCHinese(85, 2, 43);
 502   2          } 
 503   1          else if (function_mode == MODE_COUNTDOWN) {
 504   2              // ?????:????/??
 505   2              if (countdown_paused) {
 506   3                  // ?????:??????
 507   3                  ir_tx_buf[0] = CMD_START_TIMER;
 508   3                  ir_tx_buf[1] = current_time[0];  // ????
 509   3                  ir_tx_buf[2] = current_time[1];  // ????
 510   3                  ir_tx_buf[3] = current_time[2];  // ????
 511   3                  ir_tx_buf[4] = 0;
 512   3                  Uart1Print(ir_tx_buf, 5);
 513   3                  
 514   3                  countdown_paused = 0;
 515   3                  LedPrint(0x04); // LED3?(????)
 516   3                  beep_confirm();
 517   3                  OLED_Clear();
 518   3                  OLED_ShowCHinese(10, 2, 11);
 519   3                  OLED_ShowCHinese(25, 2, 12);
 520   3                  OLED_ShowCHinese(40, 2, 13);
 521   3                  OLED_ShowCHinese(55, 2, 14);
 522   3                  OLED_ShowCHinese(70, 2, 15);
 523   3                  OLED_Clear();
 524   3                  OLED_ShowCHinese(10, 2, 11);
 525   3                  OLED_ShowCHinese(25, 2, 12);
 526   3                  OLED_ShowCHinese(40, 2, 13);
 527   3                  OLED_ShowCHinese(55, 2, 41);
 528   3                  OLED_ShowCHinese(70, 2, 42);
 529   3                  OLED_ShowCHinese(85, 2, 43);
 530   3              } else {
 531   3                  // ?????:??????
 532   3                  ir_tx_buf[0] = CMD_STOP;
 533   3                  ir_tx_buf[1] = current_time[0];  // ????
 534   3                  ir_tx_buf[2] = current_time[1];  // ????
 535   3                  ir_tx_buf[3] = current_time[2];  // ????
 536   3                  ir_tx_buf[4] = 0;
 537   3                  Uart1Print(ir_tx_buf, 5);
 538   3                  
 539   3                  countdown_paused = 1;
 540   3                  LedPrint(0x08); // LED4?(????)
 541   3                  beep_confirm();
 542   3                  OLED_Clear();
 543   3                  OLED_ShowCHinese(10, 2, 11);
 544   3                  OLED_ShowCHinese(25, 2, 12);
 545   3                  OLED_ShowCHinese(40, 2, 13);
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 10  

 546   3                  OLED_ShowCHinese(55, 2, 32);
 547   3                  OLED_ShowCHinese(70, 2, 33);
 548   3              }
 549   2          }
 550   1      }
 551          
 552          void handle_key2() {
 553   1          if (function_mode == MODE_LED_CONTROL) {
 554   2              exit_led_control_mode();
 555   2              return;
 556   2          }
 557   1          
 558   1          if (function_mode == MODE_COUNTDOWN) {
 559   2              stop_countdown();
 560   2              beep_confirm();
 561   2              OLED_Clear();
 562   2              OLED_ShowCHinese(10, 2, 16);
 563   2              OLED_ShowCHinese(25, 2, 17);
 564   2              OLED_ShowCHinese(40, 2, 18);
 565   2              OLED_ShowCHinese(55, 2, 19);
 566   2          } 
 567   1          else if (function_mode == MODE_NORMAL) {
 568   2              enter_setting_mode();
 569   2              OLED_Clear();
 570   2              OLED_ShowCHinese(10, 2, 16);
 571   2              OLED_ShowCHinese(25, 2, 17);
 572   2              OLED_ShowCHinese(40, 2, 18);
 573   2              OLED_ShowCHinese(55, 2, 19);
 574   2              OLED_ShowCHinese(85, 2, 46);
 575   2          } 
 576   1          else if (function_mode == MODE_SET_TIME) {
 577   2              exit_setting_mode();
 578   2              OLED_Clear();
 579   2              OLED_ShowCHinese(10, 2, 16);
 580   2              OLED_ShowCHinese(25, 2, 17);
 581   2              OLED_ShowCHinese(40, 2, 35);
 582   2              OLED_ShowCHinese(55, 2, 36);
 583   2          }
 584   1      }
 585          
 586          void handle_nav(unsigned char nav_key) {
 587   1          if (function_mode == MODE_SET_TIME) {
 588   2              switch (nav_key) {
 589   3                  case enumAdcNavKeyLeft:
 590   3                      cursor_pos = (cursor_pos + 2) % 3;
 591   3                      OLED_Clear();
 592   3                      OLED_ShowCHinese(10, 2, 16);
 593   3                      OLED_ShowCHinese(25, 2, 17);
 594   3                      OLED_ShowCHinese(40, 2, 18);
 595   3                      OLED_ShowCHinese(55, 2, 19); // ????
 596   3                      // ????????(?/?/?)
 597   3                      if (cursor_pos == CURSOR_HOUR) OLED_ShowCHinese(85, 2, 44);
 598   3                      else if (cursor_pos == CURSOR_MINUTE) OLED_ShowCHinese(85, 2, 45);
 599   3                      else if (cursor_pos == CURSOR_SECOND) OLED_ShowCHinese(85, 2, 46);
 600   3                      beep_confirm();
 601   3                      break;
 602   3                  case enumAdcNavKeyRight:
 603   3                      cursor_pos = (cursor_pos + 1) % 3;
 604   3                      OLED_Clear();
 605   3                      OLED_ShowCHinese(10, 2, 16);
 606   3                      OLED_ShowCHinese(25, 2, 17);
 607   3                      OLED_ShowCHinese(40, 2, 18);
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 11  

 608   3                      OLED_ShowCHinese(55, 2, 19); // ????
 609   3                      // ????????(?/?/?)
 610   3                      if (cursor_pos == CURSOR_HOUR) OLED_ShowCHinese(85, 2, 44);
 611   3                      else if (cursor_pos == CURSOR_MINUTE) OLED_ShowCHinese(85, 2, 45);
 612   3                      else if (cursor_pos == CURSOR_SECOND) OLED_ShowCHinese(85, 2, 46);
 613   3                      beep_confirm();
 614   3                      break;
 615   3                  case enumAdcNavKeyUp:
 616   3                      time_set[cursor_pos]++;
 617   3                      if (cursor_pos == CURSOR_HOUR && time_set[0] > 23) time_set[0] = 0;
 618   3                      if ((cursor_pos == CURSOR_MINUTE || cursor_pos == CURSOR_SECOND) && time_set[cursor_pos] >
             - 59) {
 619   4                          time_set[cursor_pos] = 0;
 620   4                      }
 621   3                      beep_confirm();
 622   3                      break;
 623   3                  case enumAdcNavKeyDown:
 624   3                      if (time_set[cursor_pos] == 0) {
 625   4                          if (cursor_pos == CURSOR_HOUR) time_set[0] = 23;
 626   4                          else time_set[cursor_pos] = 59;
 627   4                      } else {
 628   4                          time_set[cursor_pos]--;
 629   4                      }
 630   3                      beep_confirm();
 631   3                      break;
 632   3                  case enumAdcNavKeyCenter:
 633   3                      exit_setting_mode();
 634   3                      break;
 635   3              }
 636   2              send_data_to_pc(CMD_UPDATE_TIME_PC, time_set[0], time_set[1], time_set[2], 0);
 637   2              update_display();
 638   2          }
 639   1          else if (function_mode == MODE_LED_CONTROL) {
 640   2              switch (nav_key) {
 641   3                  case enumAdcNavKeyRight:
 642   3                      led_selection = (led_selection == 0) ? 7 : led_selection - 1;
 643   3                      LedPrint(1 << led_selection);
 644   3                      update_led_display();
 645   3                      beep_confirm();
 646   3                      break;
 647   3                  case enumAdcNavKeyLeft:
 648   3                      led_selection = (led_selection + 1) % 8;
 649   3                      LedPrint(1 << led_selection);
 650   3                      update_led_display();
 651   3                      beep_confirm();
 652   3                      break;
 653   3                  case enumAdcNavKeyCenter:
 654   3                      send_led_command();
 655   3                      exit_led_control_mode();
 656   3                      break;
 657   3                  default:
 658   3                      break;
 659   3              }
 660   2          }
 661   1          else if (function_mode == MODE_NORMAL) {
 662   2              if (nav_key == enumAdcNavKeyCenter) {
 663   3                  enter_led_control_mode();
 664   3              }
 665   2          }
 666   1      }
 667          
 668          void enter_setting_mode() {
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 12  

 669   1          function_mode = MODE_SET_TIME;
 670   1          cursor_pos = CURSOR_SECOND;
 671   1          blink_state = 1;
 672   1          blink_counter = 0;
 673   1          inactivity_timer = 0;
 674   1          LedPrint(0x02);
 675   1          beep_confirm();
 676   1          update_display();
 677   1          send_data_to_pc(CMD_LOCK_PC, time_set[0], time_set[1], time_set[2], 0);
 678   1      }
 679          
 680          void exit_setting_mode() {
 681   1          function_mode = MODE_NORMAL;
 682   1          save_settings();
 683   1          LedPrint(0x00);
 684   1          beep_confirm();
 685   1          update_display();
 686   1      }
 687          
 688          void start_countdown() {
 689   1          current_time[0] = time_set[0];
 690   1          current_time[1] = time_set[1];
 691   1          current_time[2] = time_set[2];
 692   1          
 693   1          function_mode = MODE_COUNTDOWN;
 694   1          countdown_active = 1;
 695   1          countdown_paused = 0;
 696   1          
 697   1          send_tomato_command();
 698   1          send_data_to_pc(CMD_SET_POMODORO_PC, current_time[0], current_time[1], current_time[2], 0);
 699   1          
 700   1          LedPrint(0x04);
 701   1          beep_confirm();
 702   1          update_display();
 703   1      }
 704          
 705          void update_countdown() {
 706   1          if (current_time[2] > 0) {
 707   2              current_time[2]--;
 708   2          } else {
 709   2              if (current_time[1] > 0) {
 710   3                  current_time[1]--;
 711   3                  current_time[2] = 59;
 712   3              } else {
 713   3                  if (current_time[0] > 0) {
 714   4                      current_time[0]--;
 715   4                      current_time[1] = 59;
 716   4                      current_time[2] = 59;
 717   4                  }
 718   3              }
 719   2          }
 720   1          update_display();
 721   1          
 722   1          if (current_time[1] == 0 && current_time[2] == 0 && current_time[0] > 0) {
 723   2              SetBeep(1000, 50);
 724   2          }
 725   1      }
 726          
 727          void stop_countdown() {
 728   1          function_mode = MODE_NORMAL;
 729   1          countdown_active = 0;
 730   1          countdown_paused = 0;
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 13  

 731   1          
 732   1          ir_tx_buf[0] = CMD_STOP;
 733   1          IrPrint(ir_tx_buf, 5);
 734   1          send_data_to_pc(CMD_UNLOCK_PC, 0, 0, 0, 0);
 735   1          
 736   1          LedPrint(0x00);
 737   1          update_display();
 738   1      }
 739          
 740          void send_tomato_command() {
 741   1          ir_tx_buf[0] = CMD_START_TIMER;
 742   1          ir_tx_buf[1] = time_set[0];
 743   1          ir_tx_buf[2] = time_set[1];
 744   1          ir_tx_buf[3] = time_set[2];
 745   1          ir_tx_buf[4] = 0;
 746   1          
 747   1          if (IrPrint(ir_tx_buf, 5) == enumIrTxOK) {
 748   2              SetBeep(1200, 20);
 749   2              SetBeep(1500, 20);
 750   2          } else {
 751   2              beep_error();
 752   2          }
 753   1      }
 754          
 755          void save_settings() {
 756   1          NVM_Write(0, time_set[0]);
 757   1          NVM_Write(1, time_set[1]);
 758   1          NVM_Write(2, time_set[2]);
 759   1      }
 760          
 761          void load_settings() {
 762   1          unsigned char hour = NVM_Read(0);
 763   1          unsigned char minute = NVM_Read(1);
 764   1          unsigned char second = NVM_Read(2);
 765   1          
 766   1          if (hour <= 23 && minute <= 59 && second <= 59) {
 767   2              time_set[0] = hour;
 768   2              time_set[1] = minute;
 769   2              time_set[2] = second;
 770   2          }
 771   1          
 772   1          // OLED startup sequence from your code
 773   1          OLED_ShowCHinese(25, 2, 37);
 774   1          OLED_ShowCHinese(40, 2, 38);
 775   1          OLED_ShowCHinese(55, 2, 39);
 776   1          OLED_ShowCHinese(70, 2, 40);
 777   1          delay_ms(1500); // Changed from delay() to delay_ms()
 778   1          OLED_Clear();
 779   1          OLED_ShowCHinese(10, 2, 0);
 780   1          OLED_ShowCHinese(25, 2, 1);
 781   1          OLED_ShowCHinese(40, 2, 2);
 782   1          OLED_ShowCHinese(55, 2, 3);
 783   1          OLED_ShowCHinese(10, 5, 4);
 784   1          OLED_ShowCHinese(25, 5, 5);
 785   1          OLED_ShowCHinese(40, 5, 6);
 786   1          OLED_ShowCHinese(55, 5, 7);
 787   1          OLED_ShowCHinese(70, 5, 8);
 788   1          OLED_ShowCHinese(85, 5, 9);
 789   1          OLED_ShowCHinese(100, 5, 10);
 790   1          delay_ms(1500); // Changed from delay() to delay_ms()
 791   1          OLED_Clear();
 792   1          OLED_ShowCHinese(10, 2, 28);
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 14  

 793   1          OLED_ShowCHinese(25, 2, 29);
 794   1          OLED_ShowCHinese(40, 2, 30);
 795   1          OLED_ShowCHinese(55, 2, 31);
 796   1          OLED_ShowCHinese(70, 2, 20);
 797   1          OLED_ShowCHinese(85, 2, 21);
 798   1          OLED_ShowCHinese(10, 5, 22);
 799   1          OLED_ShowCHinese(25, 5, 23);
 800   1          OLED_ShowCHinese(40, 5, 24);
 801   1          OLED_ShowCHinese(70, 5, 25);
 802   1          OLED_ShowCHinese(85, 5, 27);
 803   1          OLED_ShowCHinese(100, 5, 26);
 804   1      }
 805          
 806          void beep_confirm() {
 807   1          SetBeep(1000, 10);
 808   1      }
 809          
 810          void beep_error() {
 811   1          SetBeep(500, 10);
 812   1          SetBeep(300, 10);
 813   1      }
 814          
 815          void beep_countdown_end() {
 816   1          SetBeep(1500, 100);
 817   1          SetBeep(1200, 100);
 818   1          SetBeep(1500, 100);
 819   1          LedPrint(0x0F);
 820   1      }
 821          
 822          void main() {
 823   1          // DS1302 Init
 824   1          time.year = 2025; time.day = 18; time.month = 9;
 825   1          time.hour = 1; time.minute = 18; time.second = 0;
 826   1          DS1302Init(time);
 827   1          // RTC_Write(time);
 828   1          
 829   1          // Hardware Init
 830   1          Uart1Init(9600);
 831   1          KeyInit();
 832   1          DisplayerInit();
 833   1          MusicPlayerInit();
 834   1          BeepInit();
 835   1          IrInit(NEC_R05d);
 836   1          AdcInit(ADCexpEXT);
 837   1          OLED_Init();
 838   1          OLED_Clear();
 839   1          
 840   1          // Load Settings
 841   1          load_settings();
 842   1          
 843   1          // Register Callbacks
 844   1          SetEventCallBack(enumEventKey, key_callback);
 845   1          SetEventCallBack(enumEventNav, nav_callback);
 846   1          SetEventCallBack(enumEventXADC, Rop_callback);//ÎÂ¶È
 847   1          SetEventCallBack(enumEventSys100mS, timer_100ms_callback);
 848   1          SetEventCallBack(enumEventSys1S, timer_1s_callback);
 849   1          SetEventCallBack(enumEventUart1Rxd, uart_rx_callback);
 850   1          
 851   1          // Setup Receivers
 852   1          // Setup Receivers
 853   1      // ???????,????????????? 5 ???
 854   1          SetUart1Rxd(uart1_rx_buf, 5, NULL, 20); 
C51 COMPILER V9.51   TOMATOCLOCK8                                                          09/18/2025 09:00:40 PAGE 15  

 855   1          SetIrRxd(ir_tx_buf, 5);
 856   1          
 857   1          // System Core Init
 858   1          MySTC_Init();
 859   1          
 860   1          // Initial State
 861   1          update_display();
 862   1          LedPrint(0x00);
 863   1          
 864   1          // Handshake with PC
 865   1          delay_ms(1500);
 866   1          Uart1Print("RDY\n", 4);
 867   1          beep_confirm();
 868   1          delay_ms(500);
 869   1          while(1) {
 870   2              MySTC_OS();
 871   2          }
 872   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4179    ----
   CONSTANT SIZE    =    273    ----
   XDATA SIZE       =     35      18
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
