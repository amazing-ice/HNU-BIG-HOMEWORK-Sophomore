C51 COMPILER V9.51   OLED                                                                  09/17/2025 22:58:14 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE OLED
OBJECT MODULE PLACED IN oled.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE oled.c BROWSE INCDIR(.\inc) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "oled.h"
   2          #include "oledfont.h"
   3          // OLED的显存
   4          //存放格式如下.
   5          //[0]0 1 2 3 ... 127
   6          //[1]0 1 2 3 ... 127
   7          //[2]0 1 2 3 ... 127
   8          //[3]0 1 2 3 ... 127
   9          //[4]0 1 2 3 ... 127
  10          //[5]0 1 2 3 ... 127
  11          //[6]0 1 2 3 ... 127
  12          //[7]0 1 2 3 ... 127
  13          xdata unsigned char OLED_GRAM[64][8] = {0};
  14          
  15          
  16          /*****************************************************************/
  17          //显示地图上的点
  18          //我设置的是y轴向下的坐标系
  19          void OLED_Write_GRAM(u8 x, u8 y, bit value)
  20          {
  21   1        u8 OLED_page = y / 8;
  22   1        u8 OLED_page_value = 1 << y % 8;
  23   1        if (x >= 64)
  24   1          return;
  25   1        if (value)
  26   1          OLED_GRAM[x][OLED_page] |= OLED_page_value;
  27   1        else
  28   1          OLED_GRAM[x][OLED_page] &= ~OLED_page_value;
  29   1      }
  30          /*****************************************************************/
  31          //向OLED传输显存数据
  32          //更新显存到OLED
  33          void OLED_Refresh(void)
  34          {
  35   1        unsigned char i, n;
  36   1        for (i = 0; i < 8; i++)
  37   1        {
  38   2          OLED_WR_Byte(0xb0 + i, OLED_CMD); //设置行起始地址
  39   2          OLED_WR_Byte(0x00, OLED_CMD);   //设置低列起始地址
  40   2          OLED_WR_Byte(0x10, OLED_CMD);   //设置高列起始地址
  41   2          for (n = 0; n < 64; n++)
  42   2          {
  43   3            OLED_WR_Byte(OLED_GRAM[n][i], OLED_DATA);
  44   3            // delay_ms(1);
  45   3          }
  46   2        }
  47   1        for (i = 0; i < 64; i++)
  48   1          OLED_WR_Byte(0x00, OLED_DATA);
  49   1      }
  50          void delay_ms(unsigned int ms)
  51          {
  52   1        unsigned int a;
  53   1        while (ms)
  54   1        {
  55   2          a = 1800;
C51 COMPILER V9.51   OLED                                                                  09/17/2025 22:58:14 PAGE 2   

  56   2          while (a--)
  57   2            ;
  58   2          ms--;
  59   2        }
  60   1        return;
  61   1      }
  62          
  63          //反显函数
  64          void OLED_ColorTurn(u8 i)
  65          {
  66   1        if (i == 0)
  67   1        {
  68   2          OLED_WR_Byte(0xA6, OLED_CMD); //正常显示
  69   2        }
  70   1        if (i == 1)
  71   1        {
  72   2          OLED_WR_Byte(0xA7, OLED_CMD); //反色显示
  73   2        }
  74   1      }
  75          
  76          //屏幕旋转180度
  77          void OLED_DisplayTurn(u8 i)
  78          {
  79   1        if (i == 0)
  80   1        {
  81   2          OLED_WR_Byte(0xC8, OLED_CMD); //正常显示
  82   2          OLED_WR_Byte(0xA1, OLED_CMD);
  83   2        }
  84   1        if (i == 1)
  85   1        {
  86   2          OLED_WR_Byte(0xC0, OLED_CMD); //反转显示
  87   2          OLED_WR_Byte(0xA0, OLED_CMD);
  88   2        }
  89   1      }
  90          
  91          //延时
  92          void IIC_delay(void)
  93          {
  94   1        u8 t = 1;
  95   1        while (t--)
  96   1          ;
  97   1      }
  98          
  99          //起始信号
 100          void I2C_Start(void)
 101          {
 102   1        OLED_SDA_Set();
 103   1        OLED_SCL_Set();
 104   1        IIC_delay();
 105   1        OLED_SDA_Clr();
 106   1        IIC_delay();
 107   1        OLED_SCL_Clr();
 108   1      }
 109          
 110          //结束信号
 111          void I2C_Stop(void)
 112          {
 113   1        OLED_SDA_Clr();
 114   1        OLED_SCL_Set();
 115   1        IIC_delay();
 116   1        OLED_SDA_Set();
 117   1      }
C51 COMPILER V9.51   OLED                                                                  09/17/2025 22:58:14 PAGE 3   

 118          
 119          //等待信号响应
 120          void I2C_WaitAck(void) //测数据信号的电平
 121          {
 122   1        OLED_SDA_Set();
 123   1        IIC_delay();
 124   1        OLED_SCL_Set();
 125   1        IIC_delay();
 126   1        OLED_SCL_Clr();
 127   1        IIC_delay();
 128   1      }
 129          
 130          //写入一个字节
 131          void Send_Byte(u8 dat)
 132          {
 133   1        u8 i;
 134   1        for (i = 0; i < 8; i++)
 135   1        {
 136   2          OLED_SCL_Clr(); //将时钟信号设置为低电平
 137   2          if (dat & 0x80) //将dat的8位从最高位依次写入
 138   2          {
 139   3            OLED_SDA_Set();
 140   3          }
 141   2          else
 142   2          {
 143   3            OLED_SDA_Clr();
 144   3          }
 145   2          IIC_delay();
 146   2          OLED_SCL_Set();
 147   2          IIC_delay();
 148   2          OLED_SCL_Clr();
 149   2          dat <<= 1;
 150   2        }
 151   1      }
 152          
 153          //发送一个字节
 154          //向SSD1306写入一个字节。
 155          // mode:数据/命令标志 0,表示命令;1,表示数据;
 156          void OLED_WR_Byte(u8 dat, u8 mode)
 157          {
 158   1        I2C_Start();
 159   1        Send_Byte(0x78);
 160   1        I2C_WaitAck();
 161   1        if (mode)
 162   1        {
 163   2          Send_Byte(0x40);
 164   2        }
 165   1        else
 166   1        {
 167   2          Send_Byte(0x00);
 168   2        }
 169   1        I2C_WaitAck();
 170   1        Send_Byte(dat);
 171   1        I2C_WaitAck();
 172   1        I2C_Stop();
 173   1      }
 174          
 175          //坐标设置
 176          
 177          void OLED_Set_Pos(u8 x, u8 y)
 178          {
 179   1        OLED_WR_Byte(0xb0 + y, OLED_CMD);
C51 COMPILER V9.51   OLED                                                                  09/17/2025 22:58:14 PAGE 4   

 180   1        OLED_WR_Byte(((x & 0xf0) >> 4) | 0x10, OLED_CMD);
 181   1        OLED_WR_Byte((x & 0x0f), OLED_CMD);
 182   1      }
 183          //开启OLED显示
 184          void OLED_Display_On(void)
 185          {
 186   1        OLED_WR_Byte(0X8D, OLED_CMD); // SET DCDC命令
 187   1        OLED_WR_Byte(0X14, OLED_CMD); // DCDC ON
 188   1        OLED_WR_Byte(0XAF, OLED_CMD); // DISPLAY ON
 189   1      }
 190          //关闭OLED显示
 191          void OLED_Display_Off(void)
 192          {
 193   1        OLED_WR_Byte(0X8D, OLED_CMD); // SET DCDC命令
 194   1        OLED_WR_Byte(0X10, OLED_CMD); // DCDC OFF
 195   1        OLED_WR_Byte(0XAE, OLED_CMD); // DISPLAY OFF
 196   1      }
 197          //清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!
 198          void OLED_Clear(void)
 199          {
 200   1        u8 i, n;
 201   1        for (i = 0; i < 8; i++)
 202   1        {
 203   2          OLED_WR_Byte(0xb0 + i, OLED_CMD); //设置页地址（0~7）
 204   2          OLED_WR_Byte(0x00, OLED_CMD);   //设置显示位置―列低地址
 205   2          OLED_WR_Byte(0x10, OLED_CMD);   //设置显示位置―列高地址
 206   2          for (n = 0; n < 128; n++)
 207   2            OLED_WR_Byte(0, OLED_DATA);
 208   2        } //更新显示
 209   1      }
 210          
 211          //在指定位置显示一个字符,包括部分字符
 212          // x:0~127
 213          // y:0~63
 214          // sizey:选择字体 6x8  8x16
 215          void OLED_ShowChar(u8 x, u8 y, u8 chr, u8 sizey)
 216          {
 217   1        u8 c = 0, sizex = sizey / 2;
 218   1        u16 i = 0, size1;
 219   1        if (sizey == 8)
 220   1          size1 = 6;
 221   1        else
 222   1          size1 = (sizey / 8 + ((sizey % 8) ? 1 : 0)) * (sizey / 2);
 223   1        c = chr - ' '; //得到偏移后的值
 224   1        OLED_Set_Pos(x, y);
 225   1        for (i = 0; i < size1; i++)
 226   1        {
 227   2          if (i % sizex == 0 && sizey != 8)
 228   2            OLED_Set_Pos(x, y++);
 229   2          if (sizey == 8)
 230   2            OLED_WR_Byte(asc2_0806[c][i], OLED_DATA); // 6X8字号
 231   2          else if (sizey == 16)
 232   2            OLED_WR_Byte(asc2_1608[c][i], OLED_DATA); // 8x16字号
 233   2          //    else if(sizey==xx) OLED_WR_Byte(asc2_xxxx[c][i],OLED_DATA);//用户添加字号
 234   2          else
 235   2            return;
 236   2        }
 237   1      }
 238          // m^n函数
 239          u32 oled_pow(u8 m, u8 n)
 240          {
 241   1        u32 result = 1;
C51 COMPILER V9.51   OLED                                                                  09/17/2025 22:58:14 PAGE 5   

 242   1        while (n--)
 243   1          result *= m;
 244   1        return result;
 245   1      }
 246          //显示数字
 247          // x,y :起点坐标
 248          // num:要显示的数字
 249          // len :数字的位数
 250          // sizey:字体大小
 251          void OLED_ShowNum(u8 x, u8 y, u32 num, u8 len, u8 sizey)
 252          {
 253   1        u8 t, temp, m = 0;
 254   1        u8 enshow = 0;
 255   1        if (sizey == 8)
 256   1          m = 2;
 257   1        for (t = 0; t < len; t++)
 258   1        {
 259   2          temp = (num / oled_pow(10, len - t - 1)) % 10;
 260   2          if (enshow == 0 && t < (len - 1))
 261   2          {
 262   3            if (temp == 0)
 263   3            {
 264   4              OLED_ShowChar(x + (sizey / 2 + m) * t, y, ' ', sizey);
 265   4              continue;
 266   4            }
 267   3            else
 268   3              enshow = 1;
 269   3          }
 270   2          OLED_ShowChar(x + (sizey / 2 + m) * t, y, temp + '0', sizey);
 271   2        }
 272   1      }
 273          //显示一个字符号串
 274          void OLED_ShowString(u8 x, u8 y, u8 *chr, u8 sizey)
 275          {
 276   1        u8 j = 0;
 277   1        while (chr[j] != '\0')
 278   1        {
 279   2          OLED_ShowChar(x, y, chr[j++], sizey);
 280   2          if (sizey == 8)
 281   2            x += 6;
 282   2          else
 283   2            x += sizey / 2;
 284   2        }
 285   1      }
 286          //显示汉字
 287          void OLED_ShowCHinese(u8 x, u8 y, u8 no)
 288          {
 289   1        u8 t, adder = 0;
 290   1        OLED_Set_Pos(x, y);
 291   1        for (t = 0; t < 16; t++)
 292   1        {
 293   2          OLED_WR_Byte(Hzk[2 * no][t], OLED_DATA);
 294   2          adder += 1;
 295   2        }
 296   1        OLED_Set_Pos(x, y + 1);
 297   1        for (t = 0; t < 16; t++)
 298   1        {
 299   2          OLED_WR_Byte(Hzk[2 * no + 1][t], OLED_DATA);
 300   2          adder += 1;
 301   2        }
 302   1      }
 303          
C51 COMPILER V9.51   OLED                                                                  09/17/2025 22:58:14 PAGE 6   

 304          //显示图片
 305          // x,y显示坐标
 306          // sizex,sizey,图片长宽
 307          // BMP：要显示的图片
 308          /***********功能描述：显示显示BMP图片128×64起始点坐标(x,y),x的范围0～127，y为页的范围0～7****************
             -*/
 309          void OLED_DrawBMP(unsigned char x0, unsigned char y0,unsigned char x1, unsigned char y1,unsigned char BMP[
             -])
 310          {   
 311   1       unsigned int j=0;
 312   1       unsigned char x,y;
 313   1        
 314   1        if(y1%8==0) y=y1/8;      
 315   1        else y=y1/8+1;
 316   1        for(y=y0;y<y1;y++)
 317   1        {
 318   2          OLED_Set_Pos(x0,y);
 319   2          for(x=x0;x<x1;x++)
 320   2            {      
 321   3              OLED_WR_Byte(BMP[j++],OLED_DATA);       
 322   3            }
 323   2        }
 324   1      }
 325          
 326          //????
 327          //x,y????
 328          //sizex,sizey,????
 329          //BMP:??????
 330          void OLED_DrawBMP1(u8 x,u8 y,u8 sizex, u8 sizey,u8 BMP[])
 331          {   
 332   1        u16 j=0;
 333   1        u8 i,m;
 334   1        sizey=sizey/8+((sizey%8)?1:0);
 335   1        for(i=0;i<sizey;i++)
 336   1        {
 337   2          OLED_Set_Pos(x,i+y);
 338   2          for(m=0;m<sizex;m++)
 339   2          {      
 340   3            OLED_WR_Byte(BMP[j++],OLED_DATA);       
 341   3          }
 342   2        }
 343   1      } 
 344          
 345          
 346          //初始化
 347          void OLED_Init(void)
 348          {
 349   1        OLED_RES_Clr();
 350   1        delay_ms(200);
 351   1        OLED_RES_Set();
 352   1      
 353   1        OLED_WR_Byte(0xAE, OLED_CMD); //--turn off oled panel
 354   1        OLED_WR_Byte(0x00, OLED_CMD); //---set low column address
 355   1        OLED_WR_Byte(0x10, OLED_CMD); //---set high column address
 356   1        OLED_WR_Byte(0x40, OLED_CMD); //--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)
 357   1        OLED_WR_Byte(0x81, OLED_CMD); //--set contrast control register
 358   1        OLED_WR_Byte(0xCF, OLED_CMD); // Set SEG Output Current Brightness
 359   1        OLED_WR_Byte(0xA1, OLED_CMD); //--Set SEG/Column Mapping     0xa0左右反置 0xa1正常
 360   1        OLED_WR_Byte(0xC8, OLED_CMD); // Set COM/Row Scan Direction   0xc0上下反置 0xc8正常
 361   1        OLED_WR_Byte(0xA6, OLED_CMD); //--set normal display
 362   1        OLED_WR_Byte(0xA8, OLED_CMD); //--set multiplex ratio(1 to 64)
 363   1        OLED_WR_Byte(0x3f, OLED_CMD); //--1/64 duty
C51 COMPILER V9.51   OLED                                                                  09/17/2025 22:58:14 PAGE 7   

 364   1        OLED_WR_Byte(0xD3, OLED_CMD); //-set display offset Shift Mapping RAM Counter (0x00~0x3F)
 365   1        OLED_WR_Byte(0x00, OLED_CMD); //-not offset
 366   1        OLED_WR_Byte(0xd5, OLED_CMD); //--set display clock divide ratio/oscillator frequency
 367   1        OLED_WR_Byte(0x80, OLED_CMD); //--set divide ratio, Set Clock as 100 Frames/Sec
 368   1        OLED_WR_Byte(0xD9, OLED_CMD); //--set pre-charge period
 369   1        OLED_WR_Byte(0xF1, OLED_CMD); // Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
 370   1        OLED_WR_Byte(0xDA, OLED_CMD); //--set com pins hardware configuration
 371   1        OLED_WR_Byte(0x12, OLED_CMD);
 372   1        OLED_WR_Byte(0xDB, OLED_CMD); //--set vcomh
 373   1        OLED_WR_Byte(0x40, OLED_CMD); // Set VCOM Deselect Level
 374   1        OLED_WR_Byte(0x20, OLED_CMD); //-Set Page Addressing Mode (0x00/0x01/0x02)
 375   1        OLED_WR_Byte(0x02, OLED_CMD); //
 376   1        OLED_WR_Byte(0x8D, OLED_CMD); //--set Charge Pump enable/disable
 377   1        OLED_WR_Byte(0x14, OLED_CMD); //--set(0x10) disable
 378   1        OLED_WR_Byte(0xA4, OLED_CMD); // Disable Entire Display On (0xa4/0xa5)
 379   1        OLED_WR_Byte(0xA6, OLED_CMD); // Disable Inverse Display On (0xa6/a7)
 380   1        OLED_Clear();
 381   1        OLED_WR_Byte(0xAF, OLED_CMD); /*display ON*/
 382   1      }
 383          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1461    ----
   CONSTANT SIZE    =   8010    ----
   XDATA SIZE       =    512    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      59
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
